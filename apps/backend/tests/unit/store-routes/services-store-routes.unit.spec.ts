import { GET as bookingsGET, POST as bookingsPOST } from "../../../src/api/store/bookings/route"
import { GET as educationGET } from "../../../src/api/store/education/route"
import { GET as fitnessGET } from "../../../src/api/store/fitness/route"
import { GET as freelanceGET, POST as freelancePOST } from "../../../src/api/store/freelance/route"
import { GET as healthcareGET } from "../../../src/api/store/healthcare/route"
import { GET as legalGET } from "../../../src/api/store/legal/route"
import { GET as parkingGET } from "../../../src/api/store/parking/route"
import { GET as petsGET } from "../../../src/api/store/pet-services/route"

const createRes = () => {
  const res: any = { status: jest.fn().mockReturnThis(), json: jest.fn() }
  return res
}

const createReq = (overrides: Record<string, any> = {}) => ({
  scope: { resolve: jest.fn(() => ({})) },
  query: {},
  params: {},
  body: {},
  auth_context: undefined as any,
  ...overrides,
})

describe("Services Store Routes", () => {
  beforeEach(() => jest.clearAllMocks())

  describe("Bookings /store/bookings", () => {
    const mockService = { listBookings: jest.fn(), createBooking: jest.fn(), retrieveServiceProduct: jest.fn() }

    it("GET returns 401 without auth", async () => {
      const req = createReq({ auth_context: undefined })
      const res = createRes()
      await bookingsGET(req as any, res)
      expect(res.status).toHaveBeenCalledWith(401)
    })

    it("GET returns enriched bookings", async () => {
      const bookings = [{ id: "b_1", service_product_id: "sp_1" }]
      const service = { id: "sp_1", name: "Haircut" }
      mockService.listBookings.mockResolvedValue(bookings)
      mockService.retrieveServiceProduct.mockResolvedValue(service)
      const req = createReq({
        scope: { resolve: jest.fn(() => mockService) },
        auth_context: { actor_id: "cust_1" },
      })
      const res = createRes()
      await bookingsGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith(expect.objectContaining({
        bookings: [expect.objectContaining({ id: "b_1", service })],
        count: 1,
      }))
    })

    it("GET passes status filter", async () => {
      mockService.listBookings.mockResolvedValue([])
      const req = createReq({
        scope: { resolve: jest.fn(() => mockService) },
        auth_context: { actor_id: "cust_1" },
        query: { status: "confirmed" },
      })
      const res = createRes()
      await bookingsGET(req as any, res)
      expect(mockService.listBookings).toHaveBeenCalledWith(
        expect.objectContaining({ customer_id: "cust_1", status: "confirmed" }),
        expect.any(Object),
      )
    })

    it("POST creates booking", async () => {
      const booking = { id: "b_2", service_product_id: "sp_1" }
      const service = { id: "sp_1", name: "Massage" }
      mockService.createBooking.mockResolvedValue(booking)
      mockService.retrieveServiceProduct.mockResolvedValue(service)
      const req = createReq({
        scope: { resolve: jest.fn(() => mockService) },
        auth_context: { actor_id: "cust_1" },
        body: { service_id: "sp_1", start_time: "2025-01-01T10:00:00Z", customer_email: "a@b.com" },
      })
      const res = createRes()
      await bookingsPOST(req as any, res)
      expect(res.status).toHaveBeenCalledWith(201)
      expect(res.json).toHaveBeenCalledWith({ booking: expect.objectContaining({ id: "b_2", service }) })
    })

    it("POST returns 400 when missing required fields", async () => {
      const req = createReq({ auth_context: { actor_id: "cust_1" }, body: {} })
      const res = createRes()
      await bookingsPOST(req as any, res)
      expect(res.status).toHaveBeenCalledWith(400)
    })

    it("GET handles service error", async () => {
      mockService.listBookings.mockRejectedValue(new Error("DB error"))
      const req = createReq({
        scope: { resolve: jest.fn(() => mockService) },
        auth_context: { actor_id: "cust_1" },
      })
      const res = createRes()
      await bookingsGET(req as any, res)
      expect(res.status).toHaveBeenCalledWith(500)
    })
  })

  describe("Education /store/education", () => {
    const mockService = { listCourses: jest.fn() }

    it("GET returns published courses", async () => {
      const items = [{ id: "c_1", status: "published" }]
      mockService.listCourses.mockResolvedValue(items)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await educationGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith({ items, count: 1, limit: 20, offset: 0 })
      expect(mockService.listCourses).toHaveBeenCalledWith(expect.objectContaining({ status: "published" }), expect.any(Object))
    })

    it("GET passes category and level filters", async () => {
      mockService.listCourses.mockResolvedValue([])
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) }, query: { category: "tech", level: "beginner" } })
      const res = createRes()
      await educationGET(req as any, res)
      expect(mockService.listCourses).toHaveBeenCalledWith(expect.objectContaining({ category: "tech", level: "beginner" }), expect.any(Object))
    })
  })

  describe("Fitness /store/fitness", () => {
    const mockService = { listClassSchedules: jest.fn(), listTrainerProfiles: jest.fn() }

    it("GET returns classes and trainers", async () => {
      const classes = [{ id: "cls_1" }]
      const trainers = [{ id: "tr_1" }]
      mockService.listClassSchedules.mockResolvedValue(classes)
      mockService.listTrainerProfiles.mockResolvedValue(trainers)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await fitnessGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ classes, trainers }))
    })

    it("GET handles error", async () => {
      mockService.listClassSchedules.mockRejectedValue(new Error("fail"))
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await fitnessGET(req as any, res)
      expect(res.status).toHaveBeenCalledWith(500)
    })
  })

  describe("Freelance /store/freelance", () => {
    const mockService = { listGigListings: jest.fn(), createGigListings: jest.fn() }

    it("GET returns active gig listings", async () => {
      const items = [{ id: "g_1" }]
      mockService.listGigListings.mockResolvedValue(items)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await freelanceGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith({ items, count: 1, limit: 20, offset: 0 })
      expect(mockService.listGigListings).toHaveBeenCalledWith(expect.objectContaining({ status: "active" }), expect.any(Object))
    })

    it("POST creates gig listing", async () => {
      const item = { id: "g_2" }
      mockService.createGigListings.mockResolvedValue(item)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) }, body: { title: "Gig" } })
      const res = createRes()
      await freelancePOST(req as any, res)
      expect(res.status).toHaveBeenCalledWith(201)
      expect(res.json).toHaveBeenCalledWith({ item })
    })
  })

  describe("Healthcare /store/healthcare", () => {
    const mockService = { listPractitioners: jest.fn() }

    it("GET returns practitioners accepting patients", async () => {
      const items = [{ id: "p_1" }]
      mockService.listPractitioners.mockResolvedValue(items)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await healthcareGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith({ items, count: 1, limit: 20, offset: 0 })
      expect(mockService.listPractitioners).toHaveBeenCalledWith(expect.objectContaining({ is_accepting_patients: true }), expect.any(Object))
    })

    it("GET passes specialization filter", async () => {
      mockService.listPractitioners.mockResolvedValue([])
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) }, query: { specialization: "cardiology" } })
      const res = createRes()
      await healthcareGET(req as any, res)
      expect(mockService.listPractitioners).toHaveBeenCalledWith(expect.objectContaining({ specialization: "cardiology" }), expect.any(Object))
    })
  })

  describe("Legal /store/legal", () => {
    const mockService = { listAttorneyProfiles: jest.fn() }

    it("GET returns attorney profiles", async () => {
      const items = [{ id: "att_1" }]
      mockService.listAttorneyProfiles.mockResolvedValue(items)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await legalGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith({ items, count: 1, limit: 20, offset: 0 })
    })

    it("GET handles error", async () => {
      mockService.listAttorneyProfiles.mockRejectedValue(new Error("fail"))
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await legalGET(req as any, res)
      expect(res.status).toHaveBeenCalledWith(500)
    })
  })

  describe("Parking /store/parking", () => {
    const mockService = { listParkingZones: jest.fn() }

    it("GET returns parking zones", async () => {
      const items = [{ id: "pz_1" }]
      mockService.listParkingZones.mockResolvedValue(items)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await parkingGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith({ items, count: 1, limit: 20, offset: 0 })
    })

    it("GET passes zone_type filter", async () => {
      mockService.listParkingZones.mockResolvedValue([])
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) }, query: { zone_type: "covered" } })
      const res = createRes()
      await parkingGET(req as any, res)
      expect(mockService.listParkingZones).toHaveBeenCalledWith(expect.objectContaining({ zone_type: "covered" }), expect.any(Object))
    })
  })

  describe("Pet Services /store/pet-services", () => {
    const mockService = { listPetProfiles: jest.fn() }

    it("GET returns pet profiles", async () => {
      const items = [{ id: "pet_1" }]
      mockService.listPetProfiles.mockResolvedValue(items)
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) } })
      const res = createRes()
      await petsGET(req as any, res)
      expect(res.json).toHaveBeenCalledWith({ items, count: 1, limit: 20, offset: 0 })
    })

    it("GET passes species and service_type filters", async () => {
      mockService.listPetProfiles.mockResolvedValue([])
      const req = createReq({ scope: { resolve: jest.fn(() => mockService) }, query: { species: "dog", service_type: "grooming" } })
      const res = createRes()
      await petsGET(req as any, res)
      expect(mockService.listPetProfiles).toHaveBeenCalledWith(expect.objectContaining({ species: "dog", service_type: "grooming" }), expect.any(Object))
    })
  })
})
